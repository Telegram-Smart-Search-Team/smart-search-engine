<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Telegram Smart Search – Config</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root {
      --bg: #000;
      --fg: #ddd;
      --accent: #888;
      --accent-strong: #4ade80;
      --error: #f97373;
      --card-bg: rgba(255,255,255,0.02);
      --card-border: rgba(255,255,255,0.08);
    }
    html, body {
      margin:0; padding:0;
      height:100%;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial;
    }
    body {
      display:flex;
      justify-content:center;
    }
    .page {
      width:100%;
      max-width:900px;
      padding:32px 16px 48px;
    }
    .header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:24px;
    }
    .title {
      font-size:20px;
      font-weight:600;
    }
    .subtitle {
      font-size:13px;
      opacity:.7;
    }
    .pill {
      border-radius:999px;
      padding:4px 10px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.03);
      font-size:12px;
      opacity:.9;
    }

    .chat-list {
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:72px; /* extra space at bottom */
    }
    .chat-row {
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--card-border);
      background:var(--card-bg);
      backdrop-filter:saturate(120%) blur(3px);
    }
    .chat-row.new {
      border-color:rgba(250,250,250,0.28);
    }
    .chat-row .avatar-wrap {
      width:40px;
      height:40px;
      border-radius:50%;
      overflow:hidden;
      flex-shrink:0;
      background:radial-gradient(circle at 30% 20%, #555, #111);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      color:#bbb;
    }
    .chat-row img.avatar {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .chat-main {
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .chat-title {
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chat-meta {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:11px;
      opacity:.7;
    }
    .chat-meta .badge {
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
    }
    .sources-row {
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
    }
    .source-icon {
      width:18px;
      height:18px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid rgba(255,255,255,0.18);
      opacity:.4;
      font-size:11px;
    }
    .source-icon.active {
      opacity:1;
      border-color:var(--accent-strong);
      box-shadow:0 0 0 1px rgba(74,222,128,0.35);
    }
    .btn {
      border-radius:999px;
      padding:6px 12px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.02);
      color:var(--fg);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .btn:hover {
      border-color:rgba(255,255,255,0.32);
      background:rgba(255,255,255,0.06);
    }
    .btn-primary {
      border-color:var(--accent-strong);
      background:rgba(74,222,128,0.12);
    }

    .matryoshka-toggle {
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .matryoshka-arrow {
      width:18px;
      height:18px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      transition:transform .15s ease;
      box-sizing: border-box;
      overflow: hidden;
      padding-bottom: 2px;
    }
    .matryoshka-arrow.open {
      transform:rotate(90deg);
      padding-left: 1px;
      padding-bottom: 3px;
    }
    .subchat-list {
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-top:6px;
      padding-left:46px;
      border-left:1px dashed rgba(255,255,255,0.2);
    }
    .subchat-row {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
    }
    .subchat-icon {
      width:22px;
      height:22px;
      border-radius:50%;
      overflow:hidden;
      flex-shrink:0;
      background:radial-gradient(circle at 30% 20%, #555, #111);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:13px;
      color:#bbb;
    }
    .subchat-row img.subchat-icon-img {
      width:100%;
      height:100%;
      object-fit:cover;
    }

    .loading-row {
      display:flex;
      justify-content:center;
      padding:20px 0;
    }
    .spinner {
      width:24px;
      height:24px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.15);
      border-top-color:rgba(255,255,255,0.7);
      animation:spin .7s linear infinite;
    }
    @keyframes spin {
      to { transform:rotate(360deg); }
    }

    .error-banner {
      margin-top:12px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(248,113,113,0.4);
      background:rgba(127,29,29,0.4);
      font-size:12px;
      color:#fecaca;
    }

    /* Modal */
    .modal-overlay {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.6);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal-overlay.open {
      display:flex;
    }
    .modal {
      width:min(420px, 94vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,0.16);
      background:radial-gradient(circle at top left, rgba(255,255,255,0.07), #020617);
      box-shadow:0 18px 50px rgba(0,0,0,.75);
      padding:18px 18px 16px;
    }
    .modal-header {
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:12px;
    }
    .modal-chat {
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
      flex:1;
    }
    .modal-avatar, .modal-parent-avatar, .modal-subchat-icon {
      width:32px;
      height:32px;
      border-radius:50%;
      overflow:hidden;
      background:radial-gradient(circle at 30% 20%, #555, #111);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:14px;
      color:#bbb;
      flex-shrink:0;
    }
    .modal-chat-title {
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .modal-dot {
      width:6px;
      height:6px;
      border-radius:50%;
      background:#6b7280;
      flex-shrink:0;
    }
    .modal-close {
      border:none;
      background:transparent;
      color:#9ca3af;
      cursor:pointer;
      font-size:16px;
    }
    .modal-close:hover {
      color:#e5e7eb;
    }
    .modal-section-title {
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.06em;
      opacity:.7;
      margin:6px 0 8px;
    }
    .toggle-list {
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:12px;
    }
    .toggle-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:4px 8px;
      border-radius:5px;
      cursor:pointer;
      border:1px solid transparent;
      transition:background .15s ease, border-color .15s ease;
    }
    .toggle-row:hover {
      background:rgba(15,23,42,0.9);
      border-color:rgba(148,163,184,0.6);
    }
    .toggle-label {
      font-size:13px;
    }
    .toggle-control {
      position:relative;
      width:42px;
      height:25px;
      border-radius:999px;
      background:#111827;
      border:1px solid #374151;
      flex-shrink:0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-left: 2px;
      box-sizing: border-box;
    }
    .toggle-knob {
      width:18px;
      height:18px;
      border-radius:50%;
      background:#9ca3af;
      transition:transform .18s ease, background .18s ease;
    }
    .toggle-control.on {
      background:#064e3b;
      border-color:#22c55e;
    }
    .toggle-control.on .toggle-knob {
      transform:translateX(18px);
      background:#bbf7d0;
    }
    .modal-footer {
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:4px;
    }

    footer {
        height: 72px;
    }


   /* Window variables + rebind page/footer */
:root {
  --window-max-width: 900px;
  --window-padding-x: 16px;
  --window-padding-y: 32px;
  --window-footer-height: 72px;
}

/* Override page/footer to use window vars */
.page {
  width: 100%;
  max-width: var(--window-max-width);
  padding: var(--window-padding-y) var(--window-padding-x)
           calc(var(--window-footer-height) + 16px);
}

footer {
  height: var(--window-footer-height);
}

/* MOBILE LAYOUT: dramatic change for narrow screens */
@media (max-width: 600px) {
  :root {
    --window-max-width: 100%;
    --window-padding-x: 12px;
    --window-padding-y: 20px;
    --window-footer-height: 64px;
  }

  html, body {
    font-size: 15px;
  }

  .page {
    padding: var(--window-padding-y) var(--window-padding-x)
             calc(var(--window-footer-height) + 12px);
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-bottom: 18px;
  }

  .title {
    font-size: 30px;
  }

  .subtitle {
    font-size: 17px;
    max-width: 100%;
    margin-top: 20px;
  }

  .pill {
    font-size: 13px;
    padding: 4px 8px;
    width: 100%;
    text-align: left;
    box-sizing: border-box;
    margin-top: 10px;
    display: flex;
    justify-content: center;
  }

  .chat-list {
    gap: 13px;
    margin-bottom: var(--window-footer-height);
    margin-top: 30px;
  }

  /* Chat row becomes multi-row, touch-friendly */
  .chat-row {
    align-items: flex-start;
    flex-wrap: wrap;
    align-items: center;
    flex-direction: column;
    padding: 10px 10px;
    gap: 8px;
    background: rgba(255, 255, 255, 0.07);
  }

  .chat-row .avatar-wrap {
    width: 64px;
    height: 64px;
    font-size: 22px;
  }

  .chat-main {
    flex: 1 1 calc(100% - 60px);
    flex-direction: column;
    align-items: center;
    min-width: 0;
    gap: 3px;
    padding-right: 4px;
  }

  .chat-title {
    font-size: 20px;
    white-space: normal;
    width: fit-content;
    text-wrap: inherit;
  }

  .chat-meta {
    flex-wrap: wrap;
    font-size: 11px;
    margin-top: 2px;
  }

  .sources-row {
    flex-wrap: wrap;
    row-gap: 4px;
    margin-top: 3px;
  }

  .source-icon {
    width: 20px;
    height: 20px;
    font-size: 12px;
  }

  /* Right block ("Edit" or matryoshka) goes full-width under text */
  .chat-row > div:last-child {
    flex: 1 1 100%;
    align-items: stretch !important;
    margin-top: 8px;
    width: 100%;
  }

  .chat-row > div:last-child .btn {
    width: 100%;
    justify-content: center;
  }

  .btn {
    padding: 6px 10px;
    font-size: 12px;
    width: 100%;
  }

  /* Matryoshka dropdown: full-width, clearer */
  .matryoshka-toggle {
    width: 100%;
    justify-content: space-between;
  }

  .matryoshka-arrow {
    width: 22px;
    height: 22px;
    font-size: 13px;
  }

  .subchat-list {
    /* display: flex !important; */
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
    padding-left: 0;
    border-left: none;
  }

  .subchat-row {
    padding: 6px 0;
    align-items: center;
    flex-direction: column;
    gap: 8px;
    background: rgba(255, 255, 255, 0.02);
    border-radius: 20px;
    margin-top: 8px;
  }

  .subchat-list > div:first-child {
    margin-top: 0;
  }

  .subchat-icon {
    width: 26px;
    height: 26px;
    font-size: 15px;
  }

  .subchat-row .btn {
    flex-shrink: 0;
    width: auto;
    padding-inline: 10px;
  }

  /* Modal becomes a bottom sheet with big toggles */
  .modal-overlay {
    align-items: flex-end;
  }

  .modal {
    width: 100%;
    max-width: 100%;
    margin: 0;
    border-radius: 18px 18px 0 0;
    padding: 16px 16px 18px;
    /* background:radial-gradient(circle at top left, rgba(255,255,255,0.07), #020617); */
    background: rgba(2, 6, 23, 0.85)
  }

  .modal-header {
    margin-bottom: 8px;
  }

  .modal-chat-title {
    font-size: 15px;
  }

  .modal-avatar,
  .modal-parent-avatar,
  .modal-subchat-icon {
    width: 34px;
    height: 34px;
    font-size: 15px;
  }

  .modal-section-title {
    font-size: 12px;
    margin-top: 4px;
  }

  .toggle-list {
    gap: 10px;
  }

  .toggle-row {
    padding: 8px 10px;
  }

  .toggle-label {
    font-size: 14px;
  }

  .toggle-control {
    width: 50px;
    height: 28px;
  }

  .toggle-knob {
    width: 20px;
    height: 20px;
  }

  .modal-footer {
    margin-top: 10px;
  }

  .modal-footer .btn {
    width: 100%;
    justify-content: center;
  }

  .error-banner {
    font-size: 11px;
  }

  .toggle-control.on .toggle-knob {
      transform:translateX(24px);
    }
}
  </style>
</head>
<body>
<div class="page">
  <header class="header">
    <div>
      <div class="title">Telegram Smart Search</div>
      <div class="subtitle">Configure which sources to track per chat. Changes apply instantly via Redis.</div>
    </div>
    <div class="pill">Dark panel · Lazy-loaded · Live config</div>
  </header>

  <div id="error" class="error-banner" style="display:none;"></div>

  <div id="chat-list" class="chat-list">
    <!-- rows inserted by JS -->
  </div>

  <div id="loading-row" class="loading-row" style="display:none;">
    <div class="spinner"></div>
  </div>

  <footer></footer>
</div>

<!-- Modal -->
<div id="modal-overlay" class="modal-overlay">
  <div class="modal">
    <div class="modal-header">
      <div id="modal-chat-visual" class="modal-chat">
        <!-- filled via JS -->
      </div>
      <button id="modal-close" class="modal-close" aria-label="Close">✕</button>
    </div>
    <div class="modal-section-title">Tracking sources</div>
    <div id="toggle-list" class="toggle-list">
      <!-- toggles created by JS -->
    </div>
    <div class="modal-footer">
      <button id="modal-save" class="btn btn-primary">Save</button>
    </div>
  </div>
</div>

<script>
  const PAGE_SIZE = {{ page_size|default:20 }};
  let CHAT_ORDER = [];
  let META = {};
  let loadedCount = 0;
  let isLoading = false;
  let reachedEnd = false;

  const currentConfig = {};  // chat_key -> config
  const chatEntries = {};    // entry_id -> data from /api/batch
  const subchatByKey = {};   // topic chat_key -> metadata inc parent info

  const chatListEl = document.getElementById("chat-list");
  const loadingRowEl = document.getElementById("loading-row");
  const errorEl = document.getElementById("error");

  function setError(msg) {
    if (!msg) {
      errorEl.style.display = "none";
      return;
    }
    errorEl.textContent = msg;
    errorEl.style.display = "block";
  }

  function sourceIcon(label, active) {
    const el = document.createElement("div");
    el.className = "source-icon" + (active ? " active" : "");
    el.textContent = label;
    return el;
  }

  function buildSourcesRow(cfg) {
    const row = document.createElement("div");
    row.className = "sources-row";

    row.appendChild(sourceIcon("T", !!cfg.track_text));
    row.appendChild(sourceIcon("I", !!cfg.track_image));
    row.appendChild(sourceIcon("V", !!cfg.track_video));
    row.appendChild(sourceIcon("A", !!cfg.track_audio));
    row.appendChild(sourceIcon("F", !!cfg.track_files));

    return row;
  }

//   function avatarFallbackChar(title) {
//     if (!title) return "?";
//     const t = title.trim();
//     return t ? t[0].toUpperCase() : "?";
//   }

  function avatarFallbackChar(title) {
    if (!title) return "?";

    // Trim leading whitespace
    const trimmed = title.trimStart();
    if (!trimmed) return "?";

    // Prefer Intl.Segmenter for proper grapheme clusters (handles most emoji correctly)
    if (typeof Intl !== "undefined" && Intl.Segmenter) {
        try {
        const segmenter = new Intl.Segmenter(undefined, { granularity: "grapheme" });
        const iter = segmenter.segment(trimmed)[Symbol.iterator]();
        const first = iter.next();
        if (!first.done && first.value && first.value.segment) {
            const seg = first.value.segment;
            // For letters: uppercase; for emoji this is a no-op
            return seg.toUpperCase();
        }
        } catch (e) {
        // fall through to simpler path below
        }
    }

    // Fallback: first Unicode code point (for...of iterates over code points)
    for (const ch of trimmed) {
        return ch.toUpperCase();
    }

    return "?";
  }

  function countTracked(cfg) {
    let c = 0;
    if (cfg.track_text) c++;
    if (cfg.track_image) c++;
    if (cfg.track_video) c++;
    if (cfg.track_audio) c++;
    if (cfg.track_files) c++;
    return c;
  }

  function renderChatRow(entry, meta) {
    const row = document.createElement("div");
    row.className = "chat-row";
    row.dataset.entryId = entry.entry_id;

    const m = meta || {};
    if (m.is_new) row.classList.add("new");

    // avatar
    const avatarWrap = document.createElement("div");
    avatarWrap.className = "avatar-wrap";
    if (entry.avatar_url) {
      const img = document.createElement("img");
      img.className = "avatar";
      img.src = entry.avatar_url;
      img.alt = "";
      avatarWrap.appendChild(img);
    } else {
      avatarWrap.textContent = avatarFallbackChar(entry.title);
    }

    // middle
    const main = document.createElement("div");
    main.className = "chat-main";

    const titleEl = document.createElement("div");
    titleEl.className = "chat-title";
    titleEl.textContent = entry.title;

    const metaRow = document.createElement("div");
    metaRow.className = "chat-meta";

    const typeBadge = document.createElement("span");
    typeBadge.className = "badge";
    typeBadge.textContent = entry.chat_type;
    metaRow.appendChild(typeBadge);

    const trackedSpan = document.createElement("span");
    const trackedCount = (m.tracked_sources_count != null) ? m.tracked_sources_count : countTracked(entry.config || {});
    trackedSpan.textContent = `${trackedCount} tracked`;
    metaRow.appendChild(trackedSpan);

    main.appendChild(titleEl);
    main.appendChild(metaRow);

    // right side (edit or dropdown)
    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.flexDirection = "column";
    right.style.alignItems = "flex-end";
    right.style.gap = "6px";

    if (entry.chat_type === "matryoshka_group") {
      const toggle = document.createElement("div");
      toggle.className = "matryoshka-toggle";
      const arrow = document.createElement("div");
      arrow.className = "matryoshka-arrow";
      arrow.textContent = "›";
      toggle.appendChild(arrow);

      const label = document.createElement("span");
      label.style.fontSize = "12px";
      label.style.opacity = ".8";
      label.textContent = "Subchats";
      toggle.appendChild(label);

      right.appendChild(toggle);

      const subList = document.createElement("div");
      subList.className = "subchat-list";
      subList.style.display = "none";
      right.appendChild(subList);

      toggle.addEventListener("click", () => {
        const isOpen = subList.style.display === "block";
        subList.style.display = isOpen ? "none" : "block";
        arrow.classList.toggle("open", !isOpen);

        if (!isOpen && subList.childElementCount === 0) {
          // render subchats
          (entry.subchats || []).forEach(sub => {
            subchatByKey[sub.chat_key] = {
              ...sub,
              parent_title: entry.title,
              parent_avatar_url: entry.avatar_url,
            };
            const subRow = document.createElement("div");
            subRow.className = "subchat-row";
            subRow.dataset.chatKey = sub.chat_key;

            const icon = document.createElement("div");
            icon.className = "subchat-icon";
            if (sub.icon_url) {
              const img = document.createElement("img");
              img.className = "subchat-icon-img";
              img.src = sub.icon_url;
              icon.appendChild(img);
            } else {
              icon.textContent = avatarFallbackChar(sub.title);
            }

            const title = document.createElement("div");
            title.style.flex = "1";
            title.style.minWidth = "0";
            title.style.whiteSpace = "nowrap";
            title.style.textOverflow = "ellipsis";
            title.style.overflow = "hidden";
            title.textContent = sub.title;

            const srcRow = buildSourcesRow(sub.config);
            srcRow.style.fontSize = "11px";
            srcRow.dataset.sourcesFor = sub.chat_key;

            const editBtn = document.createElement("button");
            editBtn.className = "btn";
            editBtn.textContent = "Edit";

            // editBtn.addEventListener("click", () => {
            //   openModalForChat({
            //     type: "topic",
            //     chat_key: sub.chat_key,
            //     config: sub.config,
            //     parent_title: entry.title,
            //     parent_avatar_url: entry.avatar_url,
            //     subchat_title: sub.title,
            //     subchat_icon_url: sub.icon_url,
            //   });
            // });

            editBtn.addEventListener("click", () => {
                const key = sub.chat_key;
                const latestCfg =
                    currentConfig[key] ||
                    (subchatByKey[key] && subchatByKey[key].config) ||
                    sub.config ||
                    {};

                const meta = subchatByKey[key] || sub;

                openModalForChat({
                    type: "topic",
                    chat_key: key,
                    config: latestCfg,
                    parent_title: meta.parent_title || entry.title,
                    parent_avatar_url: meta.parent_avatar_url || entry.avatar_url,
                    subchat_title: meta.title || sub.title,
                    subchat_icon_url: meta.icon_url || sub.icon_url,
                });
            });

            subRow.appendChild(icon);
            subRow.appendChild(title);
            subRow.appendChild(srcRow);
            subRow.appendChild(editBtn);

            subList.appendChild(subRow);

            currentConfig[sub.chat_key] = sub.config;
          });
        }
      });

    } else {
      const srcRow = buildSourcesRow(entry.config);
      srcRow.dataset.sourcesFor = entry.chat_key;
      main.appendChild(srcRow);

      const editBtn = document.createElement("button");
      editBtn.className = "btn";
      editBtn.textContent = "Edit";

    //   editBtn.addEventListener("click", () => {
    //     openModalForChat({
    //       type: "peer",
    //       chat_key: entry.chat_key,
    //       config: entry.config,
    //       title: entry.title,
    //       avatar_url: entry.avatar_url,
    //     });
    //   });

      editBtn.addEventListener("click", () => {
        const latestCfg = currentConfig[entry.chat_key] || entry.config || {};
        openModalForChat({
          type: "peer",
          chat_key: entry.chat_key,
          config: latestCfg,
          title: entry.title,
          avatar_url: entry.avatar_url,
        });
      });

      right.appendChild(editBtn);
    }

    row.appendChild(avatarWrap);
    row.appendChild(main);
    row.appendChild(right);

    // save config
    currentConfig[entry.chat_key] = entry.config;

    return row;
  }

  // ---------- modal ----------

  const modalOverlay = document.getElementById("modal-overlay");
  const modalChatVisual = document.getElementById("modal-chat-visual");
  const modalSave = document.getElementById("modal-save");
  const modalClose = document.getElementById("modal-close");
  const toggleListEl = document.getElementById("toggle-list");

  let modalState = null;

  function clearModal() {
    modalChatVisual.innerHTML = "";
    toggleListEl.innerHTML = "";
    modalState = null;
  }

  function createToggleRow(label, field, initial) {
    const row = document.createElement("div");
    row.className = "toggle-row";

    const lab = document.createElement("div");
    lab.className = "toggle-label";
    lab.textContent = label;

    const control = document.createElement("div");
    control.className = "toggle-control" + (initial ? " on" : "");
    const knob = document.createElement("div");
    knob.className = "toggle-knob";
    control.appendChild(knob);

    row.appendChild(lab);
    row.appendChild(control);

    row.addEventListener("click", () => {
      control.classList.toggle("on");
    });

    return {row, control};
  }

  function openModalForChat(opts) {
    clearModal();

    modalState = {
      chat_key: opts.chat_key,
      type: opts.type,
      originalConfig: {...opts.config},
    };

    // header visuals
    if (opts.type === "topic") {
      const parentAvatar = document.createElement("div");
      parentAvatar.className = "modal-parent-avatar";
      if (opts.parent_avatar_url) {
        const img = document.createElement("img");
        img.src = opts.parent_avatar_url;
        img.style.width = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";
        parentAvatar.appendChild(img);
      } else {
        parentAvatar.textContent = avatarFallbackChar(opts.parent_title);
      }

      const dot = document.createElement("div");
      dot.className = "modal-dot";

      const subIcon = document.createElement("div");
      subIcon.className = "modal-subchat-icon";
      if (opts.subchat_icon_url) {
        const img = document.createElement("img");
        img.src = opts.subchat_icon_url;
        img.style.width = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";
        subIcon.appendChild(img);
      } else {
        subIcon.textContent = avatarFallbackChar(opts.subchat_title);
      }

      const titlesBox = document.createElement("div");
      titlesBox.style.display = "flex";
      titlesBox.style.flexDirection = "column";
      titlesBox.style.minWidth = "0";

      const parentTitle = document.createElement("div");
      parentTitle.style.fontSize = "12px";
      parentTitle.style.opacity = ".7";
      parentTitle.textContent = opts.parent_title;

      const subTitle = document.createElement("div");
      subTitle.className = "modal-chat-title";
      subTitle.textContent = opts.subchat_title;

      titlesBox.appendChild(parentTitle);
      titlesBox.appendChild(subTitle);

      modalChatVisual.appendChild(parentAvatar);
      modalChatVisual.appendChild(dot);
      modalChatVisual.appendChild(subIcon);
      modalChatVisual.appendChild(titlesBox);

    } else {
      const avatar = document.createElement("div");
      avatar.className = "modal-avatar";
      if (opts.avatar_url) {
        const img = document.createElement("img");
        img.src = opts.avatar_url;
        img.style.width = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";
        avatar.appendChild(img);
      } else {
        avatar.textContent = avatarFallbackChar(opts.title);
      }

      const title = document.createElement("div");
      title.className = "modal-chat-title";
      title.textContent = opts.title;

      modalChatVisual.appendChild(avatar);
      modalChatVisual.appendChild(title);
    }

    // toggles
    const cfg = opts.config;

    const toggleSpecs = [
      { field: "track_text", label: "Text" },
      { field: "track_image", label: "Images" },
      { field: "track_video", label: "Video" },
      { field: "track_audio", label: "Audio" },
      { field: "track_files", label: "Files" },
    ];

    const toggles = {};
    toggleSpecs.forEach(spec => {
      const t = createToggleRow(spec.label, spec.field, !!cfg[spec.field]);
      toggleListEl.appendChild(t.row);
      toggles[spec.field] = t.control; // important: map by field name
    });
    modalState.toggles = toggles;

    modalOverlay.classList.add("open");
  }

  function closeModal() {
    modalOverlay.classList.remove("open");
    clearModal();
  }

  modalClose.addEventListener("click", closeModal);
  modalOverlay.addEventListener("click", (e) => {
    if (e.target === modalOverlay) closeModal();
  });

  function updatePeerUI(chatKey, cfg) {
    const row = document.querySelector('.chat-row[data-entry-id="' + chatKey + '"]');
    if (!row) return;

    const sourcesEl = row.querySelector('[data-sources-for="' + chatKey + '"]');
    if (sourcesEl) {
      const newSources = buildSourcesRow(cfg);
      newSources.dataset.sourcesFor = chatKey;
      sourcesEl.replaceWith(newSources);
    }

    const trackedCount = countTracked(cfg);
    const meta = META[chatKey] || {};
    meta.tracked_sources_count = trackedCount;
    meta.is_new = false;
    META[chatKey] = meta;

    const metaRow = row.querySelector(".chat-meta");
    if (metaRow) {
      const spans = metaRow.querySelectorAll("span");
      if (spans.length >= 2) {
        spans[1].textContent = `${trackedCount} tracked`;
      } else if (spans.length === 1) {
        const trackedSpan = document.createElement("span");
        trackedSpan.textContent = `${trackedCount} tracked`;
        metaRow.appendChild(trackedSpan);
      }
    }

    row.classList.remove("new");
  }

  function updateTopicUI(chatKey, cfg) {
    const subRow = document.querySelector('.subchat-row[data-chat-key="' + chatKey + '"]');
    if (!subRow) return;

    const sourcesEl = subRow.querySelector('[data-sources-for="' + chatKey + '"]');
    if (sourcesEl) {
      const newSources = buildSourcesRow(cfg);
      newSources.style.fontSize = "11px";
      newSources.dataset.sourcesFor = chatKey;
      sourcesEl.replaceWith(newSources);
    }

    if (subchatByKey[chatKey]) {
      subchatByKey[chatKey].config = cfg;
    }
  }

  modalSave.addEventListener("click", async () => {
    if (!modalState) return;
    const k = modalState.chat_key;
    const cfg = {
      track_text:  modalState.toggles.track_text.classList.contains("on"),
      track_image: modalState.toggles.track_image.classList.contains("on"),
      track_video: modalState.toggles.track_video.classList.contains("on"),
      track_audio: modalState.toggles.track_audio.classList.contains("on"),
      track_files: modalState.toggles.track_files.classList.contains("on"),
    };

    const before = modalState.originalConfig;
    const changed =
      cfg.track_text  !== before.track_text  ||
      cfg.track_image !== before.track_image ||
      cfg.track_video !== before.track_video ||
      cfg.track_audio !== before.track_audio ||
      cfg.track_files !== before.track_files;

    if (!changed) {
      closeModal();
      return;
    }

    try {
      const resp = await fetch("/api/chat-config", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({chat_key: k, ...cfg}),
      });
      if (!resp.ok) {
        setError("Failed to save config");
        return;
      }
      const data = await resp.json();
      if (!data.ok) {
        setError("Backend rejected config");
        return;
      }

      currentConfig[k] = cfg;

      if (modalState.type === "peer") {
        updatePeerUI(k, cfg);
      } else if (modalState.type === "topic") {
        updateTopicUI(k, cfg);
      }

      closeModal();
    } catch (err) {
      console.error(err);
      setError("Network error while saving config");
    }
  });

  // ---------- loading / infinite scroll ----------

  async function loadBootstrap() {
    setError("");
    try {
      const resp = await fetch("/api/bootstrap");
      if (!resp.ok) {
        setError("Failed to load chats list");
        return;
      }
      const data = await resp.json();
      CHAT_ORDER = data.chat_order || [];
      META = data.meta || {};
      loadedCount = 0;
      reachedEnd = CHAT_ORDER.length === 0;

      if (!reachedEnd) {
        await loadNextBatch();
      }
    } catch (err) {
      console.error(err);
      setError("Network error during bootstrap");
    }
  }

  async function loadNextBatch() {
    if (isLoading || reachedEnd) return;
    if (loadedCount >= CHAT_ORDER.length) {
      reachedEnd = true;
      return;
    }
    isLoading = true;
    loadingRowEl.style.display = "flex";

    const slice = CHAT_ORDER.slice(loadedCount, loadedCount + PAGE_SIZE);
    loadedCount += slice.length;

    try {
      const resp = await fetch("/api/batch", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({chat_ids: slice}),
      });
      if (!resp.ok) {
        setError("Failed to load batch");
        return;
      }
      const data = await resp.json();
      (data.chats || []).forEach(entry => {
        chatEntries[entry.entry_id] = entry;
        const meta = META[entry.entry_id] || {};
        const row = renderChatRow(entry, meta);
        chatListEl.appendChild(row);
      });

      if (loadedCount >= CHAT_ORDER.length) {
        reachedEnd = true;
      }

    } catch (err) {
      console.error(err);
      setError("Network error when loading batch");
    } finally {
      isLoading = false;
      loadingRowEl.style.display = "none";
    }
  }

  window.addEventListener("scroll", () => {
    const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 200;
    if (nearBottom) {
      loadNextBatch();
    }
  });

  loadBootstrap();
</script>
</body>
</html>